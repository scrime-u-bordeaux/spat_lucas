import os
import pandas as pd
import itertools
import contextlib
import wave
import numpy as np

SEQ_DIR = os.path.join(os.path.dirname(__file__), 'seq')
AUDIO_DIR = os.path.join(os.path.dirname(__file__), 'Audio')
RESAMPLE_OUTPUT_DIR = os.path.join(os.path.dirname(__file__), 'TestFolder')

TIME_SAMPLE = 0.02

class Coord:
    def __init__(self, x: float, y: float):
        self.x = x
        self.y = y

    def __repr__(self):
        return f"{self.x, self.y}\n"

def resample_figures(figures, total_duration):
    result = [
        [float(parts[-3]), float(parts[-2]), float(parts[-1])]
        for value in figures
        if len(parts := value.split()) >= 3
    ]
    resampled = []
    prev_time_window = TIME_SAMPLE

    for res in result:
        rel_time, x, y = res
        real_time = rel_time * total_duration
        # Si le temps correspond à la case en cours 
        if real_time >= prev_time_window - TIME_SAMPLE and real_time <= prev_time_window:
            resampled.append(Coord(x, y))
            prev_time_window += TIME_SAMPLE

        # Si le temps correspond à une case plus loin dans le tableau, on remplit cette case et toutes celles 
        # entre cette dernière et celle en cours     
        elif real_time >= prev_time_window:
            while prev_time_window < real_time:
                resampled.append(Coord(x, y))
                prev_time_window += TIME_SAMPLE
        else:
            continue

    return result, resampled



def resample_coord_spat():
    filename = "Basse.txt"
    df = pd.read_csv(os.path.join(SEQ_DIR, filename), header=None)


    track_indices, track_names, figures_groups = [], [], []
    current_figures = []

    for value in df.iloc[:, 1].values:
        value_str = str(value)
        if value_str.strip().startswith("id"):
            if current_figures:
                figures_groups.append(current_figures)
                current_figures = []
            track_part = value_str.split('-', 1)[0].replace('id', '').strip()
            track_index = int(track_part) if track_part.isdigit() else None
            track_indices.append(track_index)
            track_name = value_str.split('-', 1)[-1].strip().rstrip(';')
            track_names.append(track_name)
        else:
            current_figures.append(' '.join(value_str.rstrip(';').strip().split()))
    if current_figures:
        figures_groups.append(current_figures)

    combined = sorted(
        itertools.zip_longest(track_indices, track_names, figures_groups),
        key=lambda x: (x[0] if x[0] is not None else float('inf'))
    )

    track_index, track_name, figures = combined[1]

    audio_path = os.path.join(AUDIO_DIR, f"{track_name}.wav")
    if not os.path.exists(audio_path):
        raise FileNotFoundError(f"Fichier audio {track_name}.wav introuvable")

    with contextlib.closing(wave.open(audio_path, 'r')) as f:
        total_duration = f.getnframes() / f.getframerate()

    _, resampled = resample_figures(figures, total_duration)

    with open("resampled_output.txt", "w") as out_file:
        for coord in resampled:
            out_file.write(f"{coord.x} {coord.y}\n")


def compute_rms(data_instr, rate, window_sec=TIME_SAMPLE, alpha=0.2):
    window_size = int(rate * window_sec)
    print(f"Calcul de la RMS avec une taille de fenêtre de {window_size} échantillons ({window_sec} secondes)")
    num_windows = int(len(data_instr) / window_size)
    print(f"Nombre de fenêtres calculées : {num_windows}")
    rms_values = []
    for i in range(num_windows):
        start = i * window_size
        end = start + window_size
        segment = data_instr[start:end]
        if len(segment) == 0:
            continue
        rms = np.sqrt(np.mean(segment.astype(np.float64) ** 2))
        if rms_values:
            rms = alpha * rms + (1 - alpha) * rms_values[-1]
        rms_values.append(rms)
    return np.array(rms_values)

from scipy.io import wavfile
import numpy as np
import os   
import sys

from audioRMS import detect_periods
import warnings

def analyse_audio_rms(detect_played_periods = False):
    track_name = "Apostat"
    instrument_idx = 3  # Pour la guitare

   
    fname = f"Audio/{track_name}.wav"
    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        rate, data = wavfile.read(fname)
    channel_idx = instrument_idx + 1  # L'audio comporte le chan "clic"
    data_instr = data[:, channel_idx]
    rms_values = compute_rms(data_instr, rate)
    print(len(rms_values), "valeurs RMS calculées")
    # On souhaite remplir le tableau de valeur booleenne (instrument joué ou non joué)
    if(detect_played_periods):
        # Normalisation des valeurs RMS
        rms_values_norm = rms_values / np.max(rms_values) * 10 if np.max(rms_values) > 0 else rms_values
        # Détection des périodes jouées et non jouées
        joue_periods_filtrees, _, _ = detect_periods(rms_values_norm, TIME_SAMPLE)

    # On souhaite remplir le tableau de valeur RMS pure
    else:
        rms_values = rms_values
    output_dir = os.path.join("Results", "rms", track_name)

def main():
    resample_coord_spat()
    with open("resampled_output.txt", "r") as f:
        num_lines = sum(1 for _ in f)
    print(f"Nombre de lignes dans 'resampled_output.txt' : {num_lines}")
    analyse_audio_rms(True)


if __name__ == "__main__":
    main()