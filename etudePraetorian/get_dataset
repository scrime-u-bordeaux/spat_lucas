import os
import pandas as pd
import itertools
import contextlib
import wave
import numpy as np
from scipy.io import wavfile
from Utils import get_regions_from_name, indexTitre
from Utils import indexInstrument
import numpy as np
import os   
import re

from audioRMS import detect_periods
import warnings

SEQ_DIR = os.path.join(os.path.dirname(__file__), 'seq')
AUDIO_DIR = os.path.join(os.path.dirname(__file__), 'Audio')
RESAMPLE_OUTPUT_DIR = os.path.join(os.path.dirname(__file__), 'TestFolder')
RESAMPLE_DIR = os.path.join(os.path.dirname(__file__), "resampled_results")

TIME_SAMPLE = 0.02

# 0: "Voc 1"
# 1: "Voc 2"
# 2: "Guitare"
# 3: "Basse"
# 4: "BatterieG"
# 5: "BatterieD"

INSTRUMENT_IDX = 2

# 1: "APOSTAT"
# 2: "ECRAN DE FUMEE"
# 3: "L'ENNEMI"
# 4: "HYPNOSE"
# 5: "COMMUNION"
# 6: "FACE AUX GEANTS"
# 7: "NOUVEAU DIABLE"
# 8: "BALLADE ENTRE LES MINES"
# 9: "TEMPS MORT"

TRACK_IDX = 1

class Coord:
    def __init__(self, x: float, y: float):
        self.x = x
        self.y = y

    def __repr__(self):
        return f"{self.x, self.y}\n"

def get_audio_duration(path):
    with contextlib.closing(wave.open(path, 'r')) as f:
        return f.getnframes() / f.getframerate()

def resample(times, total_duration, *datas):
    """
    Resample input arrays (datas) according to the given times array,
    using a fixed time step (TIME_SAMPLE). All arrays must be of the same length.
    Returns a tuple: (resampled_times, resampled_data)
    - resampled_times: list of time points used for resampling
    - resampled_data: list of values (or tuples if multiple datas) at each time step
    """
    if not datas:
        return [], []
    n = len(times)
    if any(len(d) != n for d in datas):
        raise ValueError("All input arrays must have the same length as times.")

    resampled_data = []
    resampled_times = []

    prev_time_window = TIME_SAMPLE
    idx = 0

    while prev_time_window <= total_duration:
        if idx < n and times[idx] <= prev_time_window:
            values = tuple(d[idx] for d in datas)
            idx += 1
        else:
            values = tuple(d[idx - 1] if idx > 0 else d[0] for d in datas)

        # flatten tuple if only one data source
        resampled_data.append(values[0] if len(values) == 1 else values)
        resampled_times.append(prev_time_window)
        prev_time_window += TIME_SAMPLE

    # ➕ Complément jusqu’à la fin
    while prev_time_window <= total_duration:
        resampled_data.append(resampled_data[-1])  # répète la dernière valeur connue
        resampled_times.append(prev_time_window)
        prev_time_window += TIME_SAMPLE

    return resampled_times, resampled_data


# SPAT DATA PARSING

def parse_spat_data(print_times=False):
    filename = f"{indexInstrument[INSTRUMENT_IDX + 1]}.txt"
    print(filename, "OUAIIII")
    df = pd.read_csv(os.path.join(SEQ_DIR, filename), header=None)

    track_indices, track_names, figures_groups = [], [], []
    current_figures = []

    for value in df.iloc[:, 1].values:
        value_str = str(value)
        if value_str.strip().startswith("id"):
            if current_figures:
                figures_groups.append(current_figures)
                current_figures = []
            track_part = value_str.split('-', 1)[0].replace('id', '').strip()
            track_index = int(track_part) if track_part.isdigit() else None
            track_indices.append(track_index)
            track_name = value_str.split('-', 1)[-1].strip().rstrip(';')
            track_names.append(track_name)
        else:
            current_figures.append(' '.join(value_str.rstrip(';').strip().split()))
    if current_figures:
        figures_groups.append(current_figures)

    combined = sorted(
        itertools.zip_longest(track_indices, track_names, figures_groups),
        key=lambda x: (x[0] if x[0] is not None else float('inf'))
    )

    track_index, track_name, figures = combined[TRACK_IDX - 1]
    audio_path = os.path.join(AUDIO_DIR, f"{track_name}.wav")
    if not os.path.exists(audio_path):
        raise FileNotFoundError(f"Fichier audio {track_name}.wav introuvable")
    total_duration = get_audio_duration(audio_path)
    print(f"Durée totale (spat): {total_duration:.2f} s")

    real_times, x_coords, y_coords = zip(*[
        (float(parts[-3]) * total_duration, float(parts[-2]), float(parts[-1]))
        for value in figures if len(parts := value.split()) >= 3
    ])

    print(f"Nombre de points spatiaux : {len(real_times)}")

    

    resampled_times, resampled_coord = resample(real_times, total_duration, x_coords, y_coords)
    # Calcul de la vitesse avant le resample
    x_coords_np = np.array([pt[0] for pt in resampled_coord])
    y_coords_np = np.array([pt[1] for pt in resampled_coord])
    real_times_np = np.array(real_times)

    dx = np.diff(x_coords_np, prepend=x_coords_np[0])
    dy = np.diff(y_coords_np, prepend=y_coords_np[0])

    # dx = np.diff(x_coords_np)
    # dx = np.insert(dx, 0, 0.0)
    # dy = np.diff(y_coords_np)
    # dy = np.insert(dy, 0, 0.0)                                                      

    resampled_speed = list(zip(dx, dy))

    print(f"Nombre de points spatiaux (resamplé) : {len(dx)}")
    print(f"Nombre de points spatiaux (resamplé) : {len(dy)}")

    if not print_times:
        resampled_times = None

    return resampled_times, resampled_coord, resampled_speed

# AUDIO DATA PARSING

def compute_rms(data_instr, rate, window_sec=TIME_SAMPLE, alpha=0.2):
    print(f"Durée audio: {len(data_instr)/rate:.2f} s")
    window_size = int(rate * window_sec)
    print(f"Fréquence d'échantillonnage : {rate} Hz")
    print(f"Calcul de la RMS avec une taille de fenêtre de {window_size} échantillons ({window_sec} secondes)")
    num_windows = int(len(data_instr) / window_size)
    print(f"Nombre de fenêtres calculées : {num_windows}")
    rms_values = []
    times = []
    for i in range(num_windows):
        start = i * window_size
        end = start + window_size
        segment = data_instr[start:end]
        if len(segment) == 0:
            continue
        rms = np.sqrt(np.mean(segment.astype(np.float64) ** 2))
        if rms_values:
            rms = alpha * rms + (1 - alpha) * rms_values[-1]
        rms_values.append(rms)
        times.append(i * window_sec)
    
    return  np.array(times), np.array(rms_values)



def parse_audio_rms(print_time = False, detect_played_periods = False):
    track_name = indexTitre[TRACK_IDX]
    
    instrument_idx = INSTRUMENT_IDX + 1
    print(f"Analyse audio pour la piste : {track_name}")
    print(f"Analyse de l'instrument : {indexInstrument[instrument_idx]}")
    

   
    fname = f"Audio/{track_name}.wav"
    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        rate, data = wavfile.read(fname)
    print(instrument_idx, "oUI")
    channel_idx = instrument_idx + 1  # L'audio comporte le chan "clic"
    data_instr = data[:, channel_idx]



    times, rms_values = compute_rms(data_instr, rate)
    print(len(rms_values), "valeurs RMS calculées")
    
    

    # On souhaite remplir le tableau de valeur booleenne (instrument joué ou non joué)
    if(detect_played_periods):
        rms_values_norm = rms_values / np.max(rms_values) * 10 if np.max(rms_values) > 0 else rms_values
        joue_periods_filtrees, _, _ = detect_periods(rms_values_norm, TIME_SAMPLE)

        # Le format et le suivant : (14.3, 77.98), (81.22, 192.46), (199.38, 222.0)
        # Ecrire les temps dans un tableau et associé au premier du couple la valeur True, et au deuxième la valeur False

        played_times = []
        played_values = []
        for start, end in joue_periods_filtrees:
            played_times.append(start)
            played_values.append(1)
            played_times.append(end)
            played_values.append(0)

        audio_path = os.path.join(AUDIO_DIR, f"{track_name}.wav")
        if not os.path.exists(audio_path):
            raise FileNotFoundError(f"Fichier audio {track_name}.wav introuvable")
        total_duration = get_audio_duration(audio_path)
        resampled_times, resampled_played_values = resample(played_times, total_duration, played_values)
        time = resampled_times
        rms_values = resampled_played_values

    # On souhaite remplir le tableau de valeur RMS pure
    else:
        rms_values = rms_values
    # if not print_time:
        # print_file_content("resampled_rms", None, rms_values)
    # else:  print_file_content("resampled_rms", times, rms_values)
    return times, rms_values

def parse_regions(print_times=False):
    track_name = indexTitre[TRACK_IDX]
    regions = get_regions_from_name(track_name)

    region_names_raw = [region["name"] for region in regions]
    
    # Extraction entre apostrophes + remplacement des espaces par des underscores
    region_names = [
        re.search(r"'(.*?)'", name).group(1).replace(' ', '_')
        if re.search(r"'(.*?)'", name) else name.replace(' ', '_')
        for name in region_names_raw
    ]
    
    region_starts = [region["start"] for region in regions]
    
    audio_path = os.path.join(AUDIO_DIR, f"{track_name}.wav")
    if not os.path.exists(audio_path):
        raise FileNotFoundError(f"Fichier audio {track_name}.wav introuvable")
    
    total_duration = get_audio_duration(audio_path)

    # Resample avec la nouvelle version de la fonction
    _, resampled_regions = resample(region_starts, total_duration, region_names)

    # with open("resampled_regions.txt", "w") as out_file:
    #     for t, name in zip(resampled_times, resampled_data):
    #         if print_times:
    #             out_file.write(f"{t:.2f} {name}\n")
    #         else:
    #             out_file.write(f"{name}\n")
    # if not print_times: resampled_times = None

    if not print_times:
        resampled_times = False
    # print_file_content("resampled_regions", resampled_times, resampled_data)
    return resampled_regions

import Utils

def parse_bpm_and_calculate_positions(beats_per_measure=4, time_point=None):
    

    # Récupère le nom du morceau sélectionné
    track_name = Utils.get_track_name(TRACK_IDX)

    # Vérifie que le fichier audio existe
    audio_path = os.path.join(AUDIO_DIR, f"{track_name}.wav")
    if not os.path.exists(audio_path):
        raise FileNotFoundError(f"Fichier audio {track_name}.wav introuvable")

    # Récupère la durée totale du fichier audio
    total_duration = get_audio_duration(audio_path)

    # Charge les données BPM
    df = pd.read_csv("BPM_tracks.csv")

    # Recherche la ligne correspondante au morceau sélectionné
    track_row = df[df["name"] == track_name]
    if track_row.empty:
        raise ValueError(f"Track '{track_name}' non trouvé dans BPM_tracks.csv")

    bpm = float(track_row["bpm"].values[0])
    beat_duration = 60 / bpm
    total_beats = int(total_duration / beat_duration)
    total_measures = total_beats // beats_per_measure

    # Liste des timecodes de chaque beat
    beat_timecodes = [round(i * beat_duration, 3) for i in range(total_beats)]


    beat_times = []
    beat_units = []

    for i, t in enumerate(beat_timecodes):
        beat_in_measure = i % beats_per_measure + 1
        beat_times.append(t)
        beat_units.append(beat_in_measure)
    
    _, resampled_bpm = resample(beat_times, total_duration, beat_units)

    return resampled_bpm


def print_file_content(out_file_name, times, *datas):
    # Vérifier qu'on a au moins une colonne de données
    if not datas:
        raise ValueError("Au moins une colonne de données doit être fournie")
    
    # Vérifier que toutes les colonnes ont la même taille
    data_length = len(datas[0])
    for i, data in enumerate(datas):
        if len(data) != data_length:
            raise ValueError(f"La colonne {i} n'a pas la même taille que les autres")
    
    # Vérifier que times a la même taille si fourni
    if times and times is not False:
        if len(times) != data_length:
            raise ValueError("La colonne times n'a pas la même taille que les données")
    
    # Créer le répertoire si nécessaire
    os.makedirs(RESAMPLE_DIR, exist_ok=True)
    with open(os.path.join(RESAMPLE_DIR, f"{out_file_name}.txt"), 'w') as f:
        for i in range(data_length):
            line = ""
            
            # Ajouter le temps si fourni
            if times and times is not False:
                line += f"{times[i]:.2f} "
            
            # Ajouter les colonnes de données séparées par des espaces
            data_values = [str(data[i]) for data in datas]
            line += " ".join(data_values)
            
            f.write(line + "\n")

def create_csv_all_values():
    times, audio_data = parse_audio_rms(detect_played_periods=True)
    _, spat_coord, spat_speed = parse_spat_data()
    regions_data = parse_regions()
    measures = parse_bpm_and_calculate_positions()

    if(len(times) == len(audio_data)  == len(spat_coord) == len(spat_speed) == len(regions_data) == len(measures)): print("Même longueur de fichier")
    else: print(len(spat_speed), len(spat_coord))
    # On cherche à mettre tout ça dans un seul csv. Pour chaque ligne on prend les infos des 3 liste et on les met cote a cote dans 
    # le csv (séparé par une virgule) 


    if len(audio_data) == len(spat_coord) == len(regions_data):
        print("Création du csv...")
    else:
        raise ValueError("Les longueurs des fichiers parsés ne correspondent pas.")

    output_path = os.path.join(RESAMPLE_DIR, "dataset_all_value.csv")

    with open(output_path, "w") as out_file:
        # En-tête
        out_file.write("time,rms,region,measure,x,y\n")
        for (time, rms, (x, y), region, measure) in zip(times, audio_data, spat_coord, regions_data, measures):
            out_file.write(f"{time:.2f},{rms},{region},{measure},{x},{y}\n")

    print(f"Fichier CSV unifié créé dans : {output_path}")
    
if __name__ == "__main__":
    create_csv_all_values()